/**
 * DevExtreme (cjs/__internal/ui/list/m_list.edit.strategy.grouped.js)
 * Version: 24.1.6
 * Build date: Sat Sep 14 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _renderer = _interopRequireDefault(require("../../../core/renderer"));
var _iterator = require("../../../core/utils/iterator");
var _type = require("../../../core/utils/type");
var _query = _interopRequireDefault(require("../../../data/query"));
var _store_helper = _interopRequireDefault(require("../../../data/store_helper"));
var _m_collection_widgetEditStrategy = _interopRequireDefault(require("../../ui/collection/m_collection_widget.edit.strategy.plain"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    }
}
const LIST_ITEM_CLASS = "dx-list-item";
const LIST_GROUP_CLASS = "dx-list-group";
const SELECTION_SHIFT = 20;
const SELECTION_MASK = 1048575;
const combineIndex = function(indices) {
    return (indices.group << 20) + indices.item
};
const splitIndex = function(combinedIndex) {
    return {
        group: combinedIndex >> 20,
        item: 1048575 & combinedIndex
    }
};
const GroupedEditStrategy = _m_collection_widgetEditStrategy.default.inherit({
    _groupElements() {
        return this._collectionWidget._itemContainer().find(".dx-list-group")
    },
    _groupItemElements: $group => $group.find(".dx-list-item"),
    getIndexByItemData(itemData) {
        const groups = this._collectionWidget.option("items");
        let index = false;
        if (!itemData) {
            return false
        }
        if (itemData.items && itemData.items.length) {
            itemData = itemData.items[0]
        }(0, _iterator.each)(groups, ((groupIndex, group) => {
            if (!group.items) {
                return false
            }(0, _iterator.each)(group.items, ((itemIndex, item) => {
                if (item !== itemData) {
                    return true
                }
                index = {
                    group: groupIndex,
                    item: itemIndex
                };
                return false
            }));
            if (index) {
                return false
            }
        }));
        return index
    },
    getItemDataByIndex(index) {
        const items = this._collectionWidget.option("items");
        if ((0, _type.isNumeric)(index)) {
            return this.itemsGetter()[index]
        }
        return index && items[index.group] && items[index.group].items[index.item] || null
    },
    itemsGetter() {
        let resultItems = [];
        const items = this._collectionWidget.option("items");
        for (let i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                resultItems = resultItems.concat(items[i].items)
            } else {
                resultItems.push(items[i])
            }
        }
        return resultItems
    },
    deleteItemAtIndex(index) {
        const indices = splitIndex(index);
        const itemGroup = this._collectionWidget.option("items")[indices.group].items;
        itemGroup.splice(indices.item, 1)
    },
    getKeysByItems(items) {
        let plainItems = [];
        let i;
        for (i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        const result = [];
        for (i = 0; i < plainItems.length; i++) {
            result.push(this._collectionWidget.keyOf(plainItems[i]))
        }
        return result
    },
    getIndexByKey(key, items) {
        const groups = items || this._collectionWidget.option("items");
        let index = -1;
        const that = this;
        (0, _iterator.each)(groups, ((groupIndex, group) => {
            if (!group.items) {
                return
            }(0, _iterator.each)(group.items, ((itemIndex, item) => {
                const itemKey = that._collectionWidget.keyOf(item);
                if (that._equalKeys(itemKey, key)) {
                    index = {
                        group: groupIndex,
                        item: itemIndex
                    };
                    return false
                }
            }));
            if (-1 !== index) {
                return false
            }
        }));
        return index
    },
    _getGroups(items) {
        const dataController = this._collectionWidget._dataController;
        const group = dataController.group();
        if (group) {
            return _store_helper.default.queryByOptions((0, _query.default)(items), {
                group: group
            }).toArray()
        }
        return this._collectionWidget.option("items")
    },
    getItemsByKeys(keys, items) {
        const result = [];
        const groups = this._getGroups(items);
        const groupItemByKeyMap = {};
        const getItemMeta = key => {
            const index = this.getIndexByKey(key, groups);
            const group = index && groups[index.group];
            if (!group) {
                return
            }
            return {
                groupKey: group.key,
                item: group.items[index.item]
            }
        };
        (0, _iterator.each)(keys, ((_, key) => {
            const itemMeta = getItemMeta(key);
            if (!itemMeta) {
                return
            }
            const {
                groupKey: groupKey
            } = itemMeta;
            const {
                item: item
            } = itemMeta;
            let selectedGroup = groupItemByKeyMap[groupKey];
            if (!selectedGroup) {
                selectedGroup = {
                    key: groupKey,
                    items: []
                };
                groupItemByKeyMap[groupKey] = selectedGroup;
                result.push(selectedGroup)
            }
            selectedGroup.items.push(item)
        }));
        return result
    },
    moveItemAtIndexToIndex(movingIndex, destinationIndex) {
        const items = this._collectionWidget.option("items");
        const movingIndices = splitIndex(movingIndex);
        const destinationIndices = splitIndex(destinationIndex);
        const movingItemGroup = items[movingIndices.group].items;
        const destinationItemGroup = items[destinationIndices.group].items;
        const movedItemData = movingItemGroup[movingIndices.item];
        movingItemGroup.splice(movingIndices.item, 1);
        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
    },
    _isItemIndex: index => index && (0, _type.isNumeric)(index.group) && (0, _type.isNumeric)(index.item),
    _getNormalizedItemIndex(itemElement) {
        const $item = (0, _renderer.default)(itemElement);
        const $group = $item.closest(".dx-list-group");
        if (!$group.length) {
            return -1
        }
        return combineIndex({
            group: this._groupElements().index($group),
            item: this._groupItemElements($group).index($item)
        })
    },
    _normalizeItemIndex: index => combineIndex(index),
    _denormalizeItemIndex: index => splitIndex(index),
    _getItemByNormalizedIndex(index) {
        const indices = splitIndex(index);
        const $group = this._groupElements().eq(indices.group);
        return this._groupItemElements($group).eq(indices.item)
    },
    _itemsFromSameParent: (firstIndex, secondIndex) => splitIndex(firstIndex).group === splitIndex(secondIndex).group
});
var _default = exports.default = GroupedEditStrategy;
